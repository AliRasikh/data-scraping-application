"""
This module provides a Flask web application for scraping static
websites and saving the output to a TXT file.
It includes endpoints for scraping a website,
downloading the scraped content as a TXT file, and managing URLs in a database.
Endpoints:
- /scrape_with_bs4 (POST): Scrapes a static website and returns the raw HTML.
- /download/txt (GET): Downloads the scraped HTML content as a TXT file.

"""

import os
from os import path
from config import app, db
from flask import request, jsonify
from core.scraper import scrape_with_bs4, scrape_with_requests
from core.file_handler import scraped_data_to_txt_file, get_txt_file
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import LoginManager
from flask_login import login_user, login_required, logout_user, current_user
from backend.core.models import User, History
from core.repository import store_user_history


@app.route("/scrape", methods=["POST"])
def scrape():
    """
    Endpoint to scrape a static website and save the output to a TXT file.
    Expects a JSON body with a "url" key.
    """
    print("test")
    # retrieve the json data from the post request
    data = request.json
    url = data.get("url")
    scraping_method = data.get("scraping_method")

    # if no url is provides , return an error with http 400 status(bad request)
    if not url:
        return jsonify({"error": "URL is required"}), 400
    if not scraping_method:
        return jsonify({"error": "Scraping method is required"}), 400

    if scraping_method == "requests":
        # call the scrape website func for the scraped result
        raw_html = scrape_with_requests(url)
    elif scraping_method == "bs4":
        # call the scrape website func for the scraped result
        raw_html = scrape_with_bs4(url)
    else:
        return jsonify({"error": "Invalid scraping method"}), 400

    scraped_data_to_txt_file(raw_html)

    if current_user.is_authenticated:
        store_user_history(url, raw_html, scraping_method, current_user.id)
        print(f"Scraped data saved to DB for user {current_user.id}")

    return (
        jsonify(
            {
               "message": f"""URL Scraped
                with {scraping_method} and content saved to TXT file"""
            }
        ),
        201,
    )


@app.route("/download/txt", methods=["GET"])
def download_txt():
    """
    Endpoint to download a text file.

    This route handles GET requests to download a text file generated by the
    get_txt_file function.

    Returns:
        Response: A Flask response object containing the text file.
    """
    txt_file = get_txt_file()
    return txt_file


@app.route("/preview", methods=["GET"])
def preview():
    return jsonify(scraped_data_to_txt_file)


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.json.get('email')
        password = request.json.get('password')

        user = User.query.filter_by(email=email).first()
        if user:
            if check_password_hash(user.password, password):
                login_user(user, remember=True)
                return jsonify({"message": "Logged in successfully!"}), 200
                # user doesn't have to login every time
                # only under some circonstances
            else:
                return jsonify({"error": "Invalid password"}), 401
        else:
            return jsonify({"error": "Invalid email"}), 401


@app.route('/logout')
@login_required  # the user can't logout only when he's logged in
def logout():
    logout_user()
    return jsonify('Logged out succeccfully')
# redirect the user to the login page after logout


@app.route('/sign-up', methods=['GET', 'POST'])
def sign_up():
    if request.method == 'POST':
        email = request.json.get('email')
        first_name = request.json.get('first_name')
        password1 = request.json.get('password1')
        password2 = request.json.get('password2')

        user = User.query.filter_by(email=email).first()
        # make sure the account doesn't exist
        if user:  # if the email already exist ->error
            return jsonify({"error": "Email already exists."}), 400
        elif len(email) < 4:
            return jsonify({
                "error": "Email must be greater than 3 characters."}), 400
        elif len(first_name) < 2:
            return jsonify({
                "error": "First name must be greater than 1 character."}), 400
        elif password1 != password2:
            return jsonify({"error": "Passwords don't match."}), 400
        elif len(password1) < 7:
            return jsonify({
                "error": "Password must be at least 7 characters."}), 400
        else:
            new_user = User(email=email, first_name=first_name,
                            password=generate_password_hash(
                               password1, method='pbkdf2:sha256'))
            db.session.add(new_user)
            db.session.commit()
            login_user(new_user, remember=True)
            return jsonify({"message": "Account created!"}), 201


login_manager = LoginManager()
login_manager.init_app(app)


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


@app.route("/history", methods=["GET"])
@login_required
def history():
    user_history = History.query.filter_by(
      user_id=current_user.id).order_by(History.date.desc()).all()

    history_list = [
        {
            "url": record.url,
            "scraped_data": record.content,
            "date": record.date.strftime("%Y-%m-%d %H:%M:%S") if record.date
            else None
        }
        for record in user_history
    ]

    return jsonify(history_list), 200


if __name__ == "__main__":
    with app.app_context():
        if not path.exists("instance/" + str(os.getenv("database_uri"))):
            db.create_all()

        app.run(debug=True)
